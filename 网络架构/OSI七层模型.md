# OSI七层模型

<table border='1'>
    <tr font=‘10px’>
        <td width='15%'><b>OSI层级</b></td>
        <td width='60%'><b>功能描述</b></td>
        <td><b>TCP/IP协议族</b></td>
    </tr>
    <tr>
        <td>应用层</td>
        <td>定义了用于在网络中进行通信和数据传输的接口。如：文件传输，电子邮件，文件服务，虚拟终端。</td>
        <td>TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</td>
    </tr>
    <tr>
        <td>表示层</td>
        <td>掩盖不同系统间的数据格式的不同性； 指定独立结构的数据传输格式。如：数据格式化，代码转换，数据加密</td>
        <td>无</td>
    </tr>
    <tr>
        <td>会话层</td>
        <td>管理用户会话和对话；控制用户间逻辑连接的建立和挂断；报告上一层发生的错误。</td>
        <td>无</td>
    </tr>
    <tr>
        <td>传输层</td>
        <td>管理网络中端到端的信息传送；通过错误纠正和流控制机制提供可靠且有序的数据包传送；提供面向无连接的数据包的传送。</td>
        <td>TCP，UDP</td>
    </tr>
    <tr>
        <td>网络层</td>
        <td>定义网络设备间如何传输数据；根据唯一的网络设备地址路由数据包；提供流和拥塞控制以防止网络资源的损耗。</td>
        <td>IP，ICMP，RIP，OSPF，BGP，IGMP</td>
    </tr>
    <tr>
        <td>数据链路层</td>
        <td>物理寻址。定义操作通信连接的程序；封装数据包为数据帧；监测和纠正数据包传输错误。</td>
        <td>SLIP，CSLIP，PPP，ARP，RARP，MTU</td>
    </tr>
    <tr>
        <td>物理层</td>
        <td>定义通过网络设备发送数据的物理方式；作为网络媒介和设备间的接口；定义光学、电气以及机械特性；以二进制数据形式在物理媒体上传输数据。</td>
        <td>ISO2110，IEEE802，IEEE802.2</td>
    </tr>
</table>

**主机与主机之间网络互联过程**

假设主机A想要和主机B进行通信。主机A会从顶层应用层到物理层进行数据包封装，通过网络运输（路由器等只进行底层的三层结构数网物解析进行网络运输）给主机B，再从物理层向应用层进行数据包解封装。

![img](https://images2018.cnblogs.com/blog/1209537/201803/1209537-20180316141414426-1272016476.png)

数据包封装解封装过程：

![img](https://images2018.cnblogs.com/blog/1209537/201803/1209537-20180316141535710-1359862908.png)

假设A向B请求获取XX共享信息，则通信过程如下：

**（1）建立TCP三次握手**

1. TCP第一次握手

   A向B发送一个置位SYN(syn=j)的TCP报文，包含A使用的端口号和初始序列号x（随机序列号seq）；该序列号意味着告诉B我发送了一个编号为x的数据包，如果收到请应答。进入SYN_SENT状态。

TCP封包过程，仅仅涉及TCP/IP五层网络架构（应传网数物）：

```
1、应用层将数据传输到传输层，传输层在保证数据不变的前提下封装TCP的包头以便目标主机可以正确解包，继续向下层（网络层）传递。
2、网络层同样不会改变之前的数据包，接下来主机A首先要对目标主机作判断，他会用自己的IP地址和自己的子网掩码进行与运算结果是172.16.12.0，然后在拿自己的掩码和主机B的IP地址作与运算。若结果是172.16.12.0，这个时候他知道他们在同一网段内，这时他会封装自己的IP及目标的IP地址，同上层传下来的数据一下向下传； 若是61.152.251.0，发现不在同一个网段，注意：这时也是用自己IP和目标IP进行封装，然后向下层传递。
但在数据链路层时就不会封装目的的MAC地址，他也不知道MAC地址是什么，这时他会封装网关的MAC地址，而让网关将数据转发出去。同时在网关收到数据时候，他会查看目标IP地址，然后路由器查找自己的路由表，若存在到该网络的路由便按路由表从对应接口发出去，若路由表中没有到该网络的路由则检查是否存在默认路由，如果没有则丢弃数据包，并向源主机发送网络不可达icmp消息。若一切正常，路由器会把数据包发给了他的邻居或网络运营商的路由器上去，重复以上动作，在TTL值为0之前将数据传递给B，数据传递成功！ 

注意： 数据链路层其实包括两个子层，一是LLC子层另一个是MAC子层。我们知道在以太网中通信是物理寻址的，在这层中会封装自己的MAC地址及对方的MAC地址。当然用户是没有通知他MAC地址是多少的，这时主机会查自己的缓存表，看有没有主机B的MAC地址，如果有就封装。否则他会判断B是否和自己在同一网段。若是则发一个ARP的地址解析广播包，对于不是B的主机接收该包后会自动丢弃；B主机收到广播后则会把自己的MAC地址以广播的形式发送给A，A获取到B的MAC 保存到自己的ARP缓存中，通讯开始。若不是则发送一个广播获取网关的MAC地址，网关收到广播后向A返回自己的MAC，A按照网关的MAC地址开始通信，网关收到这个数据包后向下一跳路由网关获取MAC，把这个数据包发到下一个网关直到传输到B主机。
```

2. TCP第二次握手

   B收到SYN=1的TCP报文，必须确认A的SYN(ack=j+1)，随机序列号seq置为y，同时自己也发送一个SYN包（syn=k）,即SYN+ACK包，此时服务器进入SYN_RECV状态。

3. TCP第三次握手

   A收到B发出的SYN+ACK包，则重新向B发送确认包ACK（ack=k+1）,此包发送完毕，A和B进入ESTABLISHED（tcp连接成功）状态，完成三次握手。

   

**（2）A向B发送获取XX共享信息请求**

**（3）TCP四次挥手**

1. A发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1，此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. B收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，B就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，A向B的方向就释放了，这时候处于半关闭状态，即A已经没有数据要发送了，但是B若发送数据，A依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。（此次释放过程是为了避免B存在未传输完成的数据）
3. A 收到B的确认请求后，此时，A就进入FIN-WAIT-2（终止等待2）状态，等待B发送连接释放报文（在这之前还需要接受B发送的最后的数据）。
4. B将最后的数据发送完毕后，就向A发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，B很可能又发送了一些数据，假定此时的序列号为seq=w，此时，B就进入了LAST-ACK（最后确认）状态，等待A的确认。
5. A收到B的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，A就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命，未防止B未收到确认包，防止B不断发送FIN片段连接释放报文）的时间后，当A撤销相应的TCP后，才进入CLOSED状态。
6. B只要收到了A发出的确认，立即进入CLOSED状态。同样，撤销TCP后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
   





## 相关维护问题：

**问题1：怎么解决大量Time_Wait**

查看当前Time_Wait状态连接信息：

```bash
netstat -an | awk '/^tcp/ {print $0}' | grep -i Time_Wait #查看所有端口
netstat -an | awk '/^tcp/ {++y[$NF]} END {for(w in y) print w, y[w]}'  # 查看tcp连接所有状态当前的总个数
```

方法一：调整内核参数![image-20191210175924771](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20191210175924771.png)

配置说明：

net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；

net.ipv4.tcp_tw_reuse = 1   表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；

net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；

net.ipv4.tcp_fin_timeout=30修改系統默认的 TIMEOUT 时间。



方法二：配置如下参数

![image-20191210180055137](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20191210180055137.png)



**问题2：怎么解决请求结束后依然存在大量ESTABLISHED没有被释放**

1.一般都跟服务器的Timeout设置有联系,查看tomcat的配置文件 server.xml

![image-20191210181651732](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20191210181651732.png)

检查配置得出20000毫秒的时候acceptCount=”100” ，明显不合理，最大连接数太小。

优化：connectionTimeout改为100。acceptCount改为5000。

